### Overview

---

- 단방향 연결리스트가 무엇인지
- 리스트 구조, 내장 array 구조와 비교
- 연결 리스트 클래스를 정의하고, 데이터의 삽입, 추출, 검색, 횡단, 메소드 및 많은 기능들을 추가할 것

### 연결리스트란?

---

- 문자열, 숫자 등 무엇이던 원하는 데이터를 저장하는 자료구조
- array 처럼 순서에 따라 다수의 데이터를 저장함
    - array 의 경우 각 데이터 엘리먼트들은 위치가 지정됨
    - 각 데이터 요소들은 번호에 의해 인덱스가 부여됨
    - 새로운 데이터 요소를 추가할 때마다 그 위치에 따른 인덱스가 주어짐
- 연결리스트
    - 다음 데이터 요소를 가리키는 인덱스 없이 다수의 데이터 요소들로 구성됨
    - 객체들이 연속으로 연결되어 있는 기차와 같음
    - 데이터 요소들을 노드라고 부름
    - 연결리스트들은 다수의 노드들로 구성되고, 각각의 노드는 문자열 혹은 숫자와 같은 하나의 데이터 요소를 저장함
    - 각 노드들은 다음 노드를 가리키는 정보 역시 저장하고 있으며, 다음 노드가 없는 경우 null 을 저장함
    - 대표적인 3가지 특징
        - 헤드 : 연결 리스트의 시작 노드
        - 테일 : 연결 리스트의 마지막 노드
        - 길이 : 리스트의 길이


- 연결리스트와 Array 의 차이
    - 연결리스트는 인덱스를 가지고 있지 않음
    - tail, 즉 다음 노드에 대한 정보를 가지고 있음
    - head, 시작 노드에 대한 정보를 가지고 있음
    - 새로운 항목 추가나 제거의 경우 연결리스트를 사용하면 편리
        - array 의 경우 중간에 값이 추가될 경우 순차적인 물결효과를 감수해야 함

  ### PUSH
    
  ---

    - 주어진 값을 받아들인 후 그것을 이용해 새로운 노드를 생성하는 것
    - 헤드가 없다면 리스트가 비어있다는 것을 의미
    - 헤드와 테일 모두 새롭게 생성된 노드를 가리키면 됨
    - 리스트가 비어있지 않다면, 마지막 노드의 next 를 새롭게 생성된 노드를 가리키도록 하고, 테일이 새롭게 생성된 노드를 가리키면 됨
    - 길이를 증가시킨다.

  ### POP
    
  ---

    - 리스트에 아무것도 없을 때에는 undefiend return
    - 테일에 이를때까지 이전 노드가 어떤 것이었는지 계속 추적하고 있어야함
    - 리스트의 끝까지 따라가는 temp , 항상 한 노드 이전 것을 가리키는 pre
    - 마지막 노드 정보를 추출한 다음 처음부터 시작해서 테일이 다음 노드를 계속해서 가리키게 하는 것
    - 리스트의 길이를 1 감소
    - 나중에 반환하기 위해 제거된 노드를 별도의 변수로 저장하고 있어야 한다.

  ### Shifting
    
  ---

    - 맨 앞의 노드를 제거하는 것
    - 노드가 없을 때에는 undefiend
    - 현재 head 노드를 변수에 저장
    - 현재 헤드 노드를 현재의 [head.next](http://head.next) 에 저장

  ### UnShifting
    
  ---

    - 맨 앞에서 요소를 추가하는 것
    - 새로운 헤드를 리스트 앞에 추가하고, 새로운 헤드가 이전 헤드를 가리키게 하는 것
    - 새로운 노드를 생성한 다음 헤드가 있는지를 체크한다.
    - 헤드가 없을 경우 헤드와 테일 모두 새로운 노드를 가리키도록 설정한다.
    - 노드가 있을 경우 새롭게 생성된 노드의 next 를 현재의 헤드 값으로 설정하고, 헤드가 새롭게 생성된 노드를 가리키도록 한 다음 리스트 길이를 1 증가시킨 후 마지막으로 연결 리스트를 반환한다.

  ### Get
    
  ---

    - Get() 은 인덱스 혹은 위치를 의미하는 숫자를 인자로 받아서 주어진 위치에 있는 노드를 반환하는 메서드이다.
    - 주어진 숫자만큼 리스트를 따라간 후 해당 위치의 노드를 반환한다.
    - 입력된 숫자를 인자로 받아야 합니다.
    - 인덱스 범위에 따라 엣지 케이스가 있을 수 있다.
    - 인덱스가 음수이거나 혹은 리스트의 길이보다 같거나 클 경우 동작할 수가 없다.
    - 루프를 통해 인덱스가 지정하는 위치에 이를때까지 반복해서 이동한 다음 해당 인덱스 위치에 있는 노드를 반환한다.
    - 이동한 횟수를 추적하는 counter 를 while 루프에서 한 것처럼 .next 를 반복하여 활용하기를 권장한다.

  ### Set
    
  ---

    - set 은 위치 혹은 인덱스와 해당 인덱스에 위치한 노드를 업데이트할 값인 2개의 인자를 받아들입니다.
    - 인덱스에 위치한 값은 get() 펑션을 통해 노드를 반환한다.
    - 반환된 노드의 값은 주어진 값으로 업데이트를 한다.
    - 노드를 찾지 못하였을 때에는 true 를 반환한다.

  ### Insert
    
  ---

    - insert 는 인덱스와 값 2개의 인자를 받아들인다.
    - insert 는 해당 위치에 값을 추가한다.
    - 범위를 벗어날 때에는 false 를 리턴한다.
    - insert 는 맨 마지막 위치에도 가능하기 때문에 리스트의 길이보다 클 경우에 범위를 벗어난다.
        - 맨 마지막 위치인경우 push, 맨 앞의 경우 unshift 를 호출하면 된다.
    - get 을 통해 해당 위치의 -1 위치를 알아낸다.
    - 이전 노드의 next 를 새 노드로 연결해준다.
    - 길이를 증가시켜준다.

  ### Remove
    
  ---

    - remove 는 인덱스를 인자로 받아서 해당 인덱스에 있는 노드를 제거하고 주위에 있는 노드를 연결합니다.
    - 인덱스가 0보다 작거나 혹은 리스트 길이보다 클 경우 undefined 를 반환한다.

  ### Reverse
    
  ---

    - 인자를 받지 않고 리스트의 순설르 역으로 변경하는 메소드를 작성한다.
    - 헤드와 테일을 서로 교환하고 next 라는 새로운 변수를 생성한다.
    - prev 이라는 다른 변수를 생성하고, current 변수를 생성하고, 헤드 값으로 초기화시킨다.
    - 루프를 통해 .next 를 .next.next 로 설정하는 작업을 반복한다.
    - 현재 node 의 .next 를 이전에 바로 앞에 있던 노드를 가리키도록 설정한다.
    - 현재의 node 값을 prev 에 저장하고 node 변수에 .next 값을 저장한다.


## BigO

---

- 단일연결리스트
    - 삽입 작업과 맨 리스트 맨 앞 노드의 제거 작업이 빈번하게 사용되면 단방향 연결리스트는 인덱스보다 훌룡하다.
    - 스택, 큐 등과 같이 단방향 연결 리스트를 기반으로 작성된 특수 목적의 자료구조
- 어레이
    - 리스트의 맨 마지막에 값을 추가하는 경우는 어레이가 쉽다.
    - 어레이는 내장된 인덱스를 가지고 있다.