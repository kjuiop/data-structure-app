
# 합병정렬

---

- 버블정렬, 선택정렬, 삽입정렬의 한계
    - 20개짜리 항목 배열과 같이 작은 규모에 작동
    - 그러나 10만개의 요소로 작업할 경우에는 잘 적용되지 않음
- 합병정렬, 퀵정렬, 지수정렬의 성능
    - O(n^2) 에서 O(n log n) 으로 시간복잡도를 향상시킬 수 있음
    - 그러나 효율적이고 간단하지 않음
    - 이 알고리즘은 확실히 더 어렵고, 길며, 이상함

```java
let data = Array.from({length: 100000}, () => Math.random());

10만개의 숫자를 랜덤으로 뽑아 함수에 대입함

```

### 합병정렬

---

- 합병정렬은 분할, 정렬, 합병이 모두 일어남
- 0개 요소, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용함
- 배열을 더 작은 배열로 나누는 방식, 더 큰 배열을 나누고 더 작은 배열을 정렬함
    - 분할 정복 알고리즘
- 단일요소가 생길때까지 뱅령르 계속해서 나눈 후, 단일 배열부터 서로 다른 두 배열의 요소 중 어떤 값이 더 큰지 정렬하고 계속 반복한다.

### 합병정렬 구현 방법

- 배열이 정렬되어 있다고 가정하고, 정렬된 배열 두 개의 조합을 반환하기만 하면 된다.
- 정렬된 두 배열 합병을 담당할 함수를 먼저 구현하는 것이 좋다.
- 정렬된 두 배열이 주어지면 정렬된 새 배열을 만든다.
- 시간복잡도 O(n+m) 과 공간복잡도 O(n+m) 으로 실해오딘다.
    - n 과 m 이란 함수에 첫 번째 배열과 두 번째 배열이라는 두가지 입력을 말한다.
    - n 이 첫 번째 배열의 크기이며, m 은 두 번째 배열의 크기이다.
    - n 이 아주 커지지만 m 은 아주 커지지 않는다면 그냥 n+m 이다.

- 빈 배열을 만든다.
- 입력 2개를 취하는 함수를 정의하여 마지막에 반환할 빈 배열을 만든다.
- 각 입력 배열에서 가장 작은 값부터 시작한다.
- 카운터는 i 와 j 를 사용하고, while 루프를 사용한다.
- j 와 i, 또는 두 숫자는 0부터 시작한다.
- 아직 살펴보지 않은 값이 있다면, i 와 j가 각각의 배열 끝에 도달하지 않았다면, 첫 번째 배열의 값으로 첫 번째 항목을 취한 다음 두 번째 배열의 첫 번째 항목 값과 비교합니다.
- 첫 번째 항목이 더 작다면 결과 배열에 집어 넣은 다음 첫 번째 배열의 다음 항목으로 넘어갑니다.
- 배열 하나를 완료한 다음에는 다른 배열의 남은 값을 모두 넣습니다.
- 두 배열은 같은 방식으로 정렬되어 있어야 한다. (오름차순, 내림차순 등)


<br />

# 합병정렬 시간복잡도

---

![Screen Shot 2023-05-12 at 8 14 17 AM](https://github.com/kjuiop/data-structure-app/assets/41246605/ff5819d9-8896-4af4-a1ba-20dceb10ed4c)


- 연산은 배열의 n 의 루트 번 하게 된다.
    - 8 → 2^3 = 3번 분할하게 됨
    - n 의 길이가 늘어날 수록 비교에 대한 O(n) 번 연산하게 된다.
    - 그러나 이 연산은 분할 할 때마다 반복하게 된다.
    - 그래서 n * log n 이다.

- 합병정렬의 경우, 연산을 할 때 많은 수의 배열을 저장해야 하기 때문에 O(n) 이다.